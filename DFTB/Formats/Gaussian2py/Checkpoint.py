"""
read formatted G09 checkpoint files

WARNING: Titles in the Gaussian input script should start with a character,
otherwise the title is mistaken for a data block in the checkpoint file.
"""
import numpy as np
import re

def read_float_block(fh, N):
    """
    read a block of N floats separated into 5 columns
    """
    nrow = N/5
    if N % 5 != 0:
        nrow += 1
    data = []
    for i in range(0, nrow):
        l = fh.readline().replace("D", "E")
        parts = l.strip().split()
        row = []
        for p in parts:
            try:
                row.append( float(p) )
            except ValueError as e:
                print e
                # If the number cannot be read because of some formatting
                # error, it is assumed to be 0.
                row.append( 0.0 )
        data += row
    assert len(data) == N
    return np.array(data, dtype=float)

def read_int_block(fh, N):
    """
    read a block of N integers separated into 6 columns
    """
    nrow = N/6
    if N % 6 != 0:
        nrow += 1
    data = []
    for i in range(0, nrow):
        l = fh.readline()
        parts = l.strip().split()
        data += map(int, parts)
    assert len(data) == N
    return np.array(data, dtype=int)

def read_char_block(fh, N):
    """
    read a block of N lines of characters
    """
    data = ""
    for i in range(0, N):
        l = fh.readline()
        data += l + "\n"
    return data


class _Block(object):
    def __init__(self, args, fh):
        pass
    def getName(self):
        return self.__class__.__name__.replace("_Block", "")
    def getPy(self):
        """returns a representation that can be used with python"""
        pass

class _IgnoreBlock(_Block):
    pass

class single_int_Block(_Block):
    def __init__(self, args, fh):
        assert args[0] == "I"
        self.integer = int(args[1])
    def getPy(self):
        return self.integer

class _Number_of_atoms_Block(single_int_Block):
    pass
    
class _Charge_Block(single_int_Block):
    pass

class int_Block(_Block):
    def __init__(self, args, fh):
        assert args[0] == "I"
        N = int(args[2])
        self.data = read_int_block(fh, N)
    def getPy(self):
        return self.data
    
class float_Block(_Block):
    def __init__(self, args, fh):
        assert args[0] == "R"
        N = int(args[2])
        self.data = read_float_block(fh, N)
    def getPy(self):
        return self.data

class char_Block(_Block):
    def __init__(self, args, fh):
        assert args[0] == "C"
        N = int(args[2])
        self.data = read_char_block(fh, N)
    def getPy(self):
        return self.data
    
##########################################

class _Atomic_numbers_Block(int_Block):
    pass

class _Nuclear_charges_Block(float_Block):
    pass

class _Int_Atom_Types_Block(int_Block):
    pass

class _MM_charges_Block(float_Block):
    pass

class _Current_cartesian_coordinates_Block(float_Block):
    pass

class _Mulliken_Charges_Block(float_Block):
    pass

class _Cartesian_Gradient_Block(float_Block):
    def getPy(self):
        return self.data

# for checkpoint files generated by QChem
class _Cartesian_Forces_Block(float_Block):
    def getPy(self):
        return self.data

    
class  _Cartesian_Force_Constants_Block(float_Block):
    def getPy(self):
        # Hessian contains lower triangular matrix
        # with N*(N+1)/2 entries where N=Nat*3
        M = len(self.data)
        N = int( 0.5 * (np.sqrt(1.0 + 8.0*M) - 1.0) )
        Nat = int( N/3.0 )
        assert (3*Nat)*(3*Nat+1)/2 == M

        Hess = np.zeros((N,N))
        for j in range(1, N+1):
            for i in range(1,j+1):
                indx = (j-1)*j/2+i-1
                hij = self.data[indx]
                Hess[i-1,j-1] = hij
                # hessian is symmetric
                Hess[j-1,i-1] = Hess[i-1,j-1]
        return Hess

class _Dipole_Moment_Block(float_Block):
    pass

class _Dipole_Derivatives_Block(float_Block):
    pass

class _Nonadiabatic_coupling_Block(float_Block):
    pass

class _ETran_state_values_Block(float_Block):
    def getPy(self):
        # In the section 'ETran state values' the total energy
        # and various transition dipole moments (electric, magnetic)
        # for all states are lumped together into one array.
        # The data belonging to one excited state is 16 floats long.
        block_size = 16
        nstates = len(self.data)/block_size
        total_energies = []
        electric_dipoles = []
        magnetic_dipoles = []
        for i in range(0, nstates):
            # total energy of i-th excited state (in Hartree)
            enI = self.data[i*block_size]
            total_energies.append( enI )
            # transition dipole between ground state and i-th excited state (in dipole approximation) in a.u.
            tdipI = self.data[i*block_size+1:i*block_size+1+3]
            electric_dipoles.append(np.array(tdipI))
            # magnetic transition dipole in a.u.
            tmagI = self.data[i*block_size+7:i*block_size+7+3]
            magnetic_dipoles.append(np.array(tmagI))

        return {"total_energies"  : np.array(total_energies),
                "electric_dipoles": electric_dipoles,
                "magnetic_dipoles": magnetic_dipoles}
    

###########################################

class _Gaussian_Version_Block(char_Block):
    pass

###########################################
class single_float_Block(_Block):
    def __init__(self, args, fh):
        assert args[0] == "R"
        self.f = float(args[1])
    def getPy(self):
        return self.f

class _Total_Energy_Block(single_float_Block):
    pass

class _SCF_Energy_Block(single_float_Block):
    pass

class _IRC_point_Block(float_Block):
    def __init__(self, args, fh):
        assert args[-3] == "R"
        self.quantity = args[1]
        N = int(args[-1])
        self.data = read_float_block(fh, N)
    def getName(self):
        return "_IRC_point_%s" % self.quantity
    def getPy(self):
        return self.data
        
class _IRC_Number_of_geometries_Block(int_Block):
    pass

def get_block_type_args(l):
    parts = l.split(" ")
    block_type = ""
    args = []
    for ip,p in enumerate(parts):
        if p == "":
            args = " ".join(parts[ip:]).split()
            break
        else:
            block_type += "_" + p
    # replace reserved characters
    block_type = re.sub(r'\W+', "_", block_type)
    return block_type, args

def parseCheckpointFile(filename, convert=True):
    Data = {}
    """A dictonary containing all the blocks read."""
    #print "reading checkpoint file '%s'" % filename
    fh = open(filename, 'r')
    block = _IgnoreBlock([], fh)
    while True:
        line = fh.readline()
        if line == "":
            # end of file
            break
        if line[0].isupper():
            """A capital letter starts a block of information. 
            The name of the block is used to find the correct derived class 
            (by appending _Block). """
            block_type, args = get_block_type_args(line)
            try:
                block = eval(block_type + "_Block")(args, fh)
                """call the constructor of a class that bears the same name as the current block"""
                Data[block.getName()] = block
            except NameError:
#                print "Cannot read blocks of type %s" % block_type
                block = _IgnoreBlock(args, fh)
    fh.close()
    PyData = {}
    if convert == True:
        """convert blocks into format suitable for PyQuante"""
        for (block_type, block) in Data.iteritems():
            PyData[block_type] = block.getPy()
        return(PyData)
    else:
        return Data

if __name__ == "__main__":
    import sys

    usage = "python %s <Gaussian checkpoint file>" % sys.argv[0]
    if len(sys.argv) < 2:
        print usage
        exit(-1)

    chk_file = sys.argv[1]
    Data = parseCheckpointFile(chk_file)
    print Data.keys()
