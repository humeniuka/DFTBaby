#!/usr/bin/env python
"""
A DFTB calculation is performed to HOMO of a polyomino. 
The MO coefficients at the meso and beta carbons is taken as a measure
for the reactivity of this site. A sketch of a polyomino as a collection
of little squares is drawn and the reactivities at the meso and beta
positions are drawn as coloured disk the size of which is proportional
to the reactivity of the polyomino radical cation.

New porphyrin unit will attach most likely to the most reactive sites.

Example:

   python polyominos_reactivity.py flakes_0003.xyz --verbose=0

The geometries of the flakes_####.xyz can be generated by `porphyrin_flakes.py`
"""
from DFTB import XYZ
from DFTB.DFTB2 import DFTB2
from DFTB import optparse
from DFTB.ImplicitSolvent import SolventCavity
from DFTB.Molden import MoldenExporter

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import patches

def atomistic_dftb(atomlist):
    """
    perform an atomistic tight-binding DFT calculation to get the ground state 
    and the molecular orbitals
    
    """
    # get parameters controlling DFTB calculation from
    # command line or configuration file
    usage = "Type --help to show all options for DFTB"

    parser = optparse.OptionParserFuncWrapper(
        [DFTB2.__init__, 
         DFTB2.runSCC,
         SolventCavity.__init__,
         MoldenExporter.export
        ], usage, section_headers=["DFTBaby"],
        unknown_options="ignore")
    options, args = parser.parse_args(DFTB2.__init__)
    
    dftb2 = DFTB2(atomlist, **options)
    (scf_options, args) = parser.parse_args(dftb2.runSCC)
    
    # solvent cavity
    (solvent_options, args) = parser.parse_args(SolventCavity.__init__)
    solvent_cavity = SolventCavity(**solvent_options)
    dftb2.setSolventCavity(solvent_cavity)
    
    dftb2.setGeometry(atomlist, charge=0.0)
    dftb2.getEnergy(**scf_options)

    # export molden file with orbitals
    (options, args) = parser.parse_args(MoldenExporter(None).export)
    molden = MoldenExporter(dftb2)
    molden.export(**options)
    
    return dftb2

def find_beta_meso_carbons(atomlist):
    """
    Assuming that `atomlist` contains the geometry of a beta-beta, meso-meso, beta-beta
    fused porphyrin polyomino, this functions finds the indices of the exterior
    beta and meso carbons, which can be identified by the two conditions

      1) The carbon is bonded to a hydrogen atom
      2) There are exactly one (for beta) or exactly two (for meso) nitrogen atoms 
         in the list of second nearest neighbours.

    Parameters
    ----------
    atomlist       :   geometry of porphyrin polyomino
    
    Returns
    -------
    beta_carbons   :   list of indeces into atomlist (starting at 0)
                       of beta carbons
    beta_hydrogens :   list of indeces into atomlist (starting at 0)
                       of hydrogens bound to beta carbons
    meso_carbons   :   list of indeces into atomlist (starting at 0)
                       of meso carbons
    beso_hydrogens :   list of indeces into atomlist (starting at 0)
                       of hydrogens bound to meso carbons
    """        
    C = XYZ.connectivity_matrix(atomlist)
    # indices (into atomlist) of exterior beta and meso carbon atoms
    beta_carbons = []
    meso_carbons = []
    # indices (into atomlist) of beta and meso hydrogens
    beta_hydrogens = []
    meso_hydrogens = []
    
    for i,(Zi,pos) in enumerate(atomlist):
        # Is this a carbon atom ?
        if Zi != 6:
            continue
        
        # nearest neighbours
        neighbours1 = np.where(C[i,:] == 1)[0]
        for j in neighbours1:
            Zj = atomlist[j][0]
            # Is the carbon bonded to a hydrogen atom?
            if Zj == 1:
                break
        else:
            # No hydrogen was found in the list of nearest neighbours,
            # so this cannot be a meso carbon.
            continue
        
        # list of second nearest neighbours
        neighbours2 = []
        for k in neighbours1:
            neighbours2 += list( np.where(C[k,:] == 1)[0] )
        # delete duplicates in list
        neighbours2 = list(set(neighbours2))
        
        # Are there exactly two nitrogens in the list of second-nearest neighbour atoms?
        num_nitrogens = 0
        for k in neighbours2:
            Zk = atomlist[k][0]
            if Zk == 7:
                num_nitrogens += 1
        if num_nitrogens == 1:
            beta_carbons.append(i)
            beta_hydrogens.append(j)
        elif num_nitrogens == 2:
            meso_carbons.append(i)
            meso_hydrogens.append(j)
            
    return beta_carbons, beta_hydrogens, meso_carbons, meso_hydrogens
    

def plot_simplified_polyomino(atomlist,
                              beta_carbons, beta_hydrogens, beta_density,
                              meso_carbons, meso_hydrogens, meso_density,
                              ax):
    """
    Each porphyrin unit is represented as a little square
    """
    # find metal atoms
    metal = []
    for i,(Zi,posi) in enumerate(atomlist):
        if Zi > 20:
            # could be Zn, Ni, Pd
            metal.append(i)
    # diameter of porphyrin in bohr
    d = 13.133
    # add fused C=C bond length
    d += 2.56

    dx = d / np.sqrt(2.0)
    dy = dx
    
    # plot a little square around each metal
    for i in metal:
        # position of metal
        x0,y0,z0 = atomlist[i][1]
        # corners of square (tilted by 45 degrees)
        #  /\
        #  \/
        # The last point has to be repeated to close the loop.
        xpos = np.array([x0-dx,x0   ,x0+dx,x0   , x0-dx])
        ypos = np.array([y0   ,y0-dy,y0   ,y0+dy, y0])
        ax.plot(xpos,ypos, ls="-", lw=1.5, color="black", alpha=0.6)
        ax.fill(xpos,ypos, color="grey")

    # plot reactivities (taken as the HOMO densities at
    # the beta and meso positions)
    exterior_carbons = beta_carbons + meso_carbons
    hydrogens = beta_hydrogens + meso_hydrogens
    density = list(beta_density) + list(meso_density)

    # normalize densities, such that the sum of the densities
    # at the points where new porphyrins can be attached equals 1
    density = np.array(density)
    density /= np.sum(density)

    for ic, ih, density_i in zip(exterior_carbons, hydrogens, density):
        # position of carbon
        pos_c = np.array(atomlist[ic][1])
        # position of hydrogen bound to carbon
        pos_h = np.array(atomlist[ih][1])

        # position of disk
        a = 0.2
        x,y,z = a * pos_c + (1-a) * pos_h
        
        # plot coloured disk at meso or beta position indicating
        # the electrophilic reactivity of the polyomino radical
        # cation.
        scale = 10.0
        disk = patches.Circle((x,y), radius=density_i*scale,
                              fill=True, color="red")
        ax.add_patch(disk)
    
    
def homo_density_on_atoms(dftb2, atoms):
    """
    
    Parameters
    ----------
    dftb2    :  instance of DFTB2 object, after performing an SCF calculation
    atoms    :  list of atom indices (starting at 0)

    Returns
    -------
    density  :  density[i] is the sum of the squares of the MO 
                coefficients belonging to atom atoms[i]
                
    """
    HOMO,LUMO = dftb2.getFrontierOrbitals()
    orbs = dftb2.getKSCoefficients()
    
    # density of HOMO orbital at the atomic position
    density = np.zeros(len(atoms))
    
    mu = 0
    for i,(Zi,posi) in enumerate(dftb2.atomlist):
        # iterate over orbitals on center i
        for (ni,li,mi) in dftb2.valorbs[Zi]:
            # iterate over atoms
            for k in range(0, len(atoms)):
                if i == atoms[k]:
                    density[k] += abs(orbs[mu,HOMO])**2

            # increase AO counter
            mu += 1

    return density
            
if __name__ == "__main__":
    import sys
    import os.path
    
    args = sys.argv[1:]

    if len(args) < 1:
        print ""
        print "Usage: %s  flakes_####.xyz" % os.path.basename(sys.argv[0])
        print ""
        print "  perform DFTB calculation on Zn-porphyrin polyomino"
        print "  and plot electron density of HOMO (~reactivity)"
        print ""
        exit(-1)
    
    xyz_file = sys.argv[1]
    svg_file = xyz_file.replace(".xyz", "") + ".svg"
    
    # load geometry of porphyrin flake
    atomlist = XYZ.read_xyz(xyz_file)[0]

    beta_carbons, beta_hydrogens, meso_carbons, meso_hydrogens = find_beta_meso_carbons(atomlist)

    # compute electronic structure
    dftb2 = atomistic_dftb(atomlist)

    beta_density = homo_density_on_atoms(dftb2, beta_carbons)
    meso_density = homo_density_on_atoms(dftb2, meso_carbons)

    print "Indeces of beta carbons"
    print [i+1 for i in beta_carbons]
    print "Density of HOMO at beta carbons"
    print beta_density
    
    print "Indeces of meso carbons"
    print [i+1 for i in meso_carbons]
    print "Density of HOMO at meso carbons"
    print meso_density

    # plot sketch of polyomino
    ax = plt.gca()
    ax.clear()
    #ax.set_xlim((-width,width))
    #ax.set_ylim((-height,height))
    ax.axis('off')
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    ax.set_aspect('equal', 'datalim')

    plot_simplified_polyomino(atomlist,
                              beta_carbons, beta_hydrogens, beta_density,
                              meso_carbons, meso_hydrogens, meso_density,
                              ax)
    plt.savefig(svg_file, transparent=True)
    
    #plt.show()
    
