#!/usr/bin/env python
"""
compute electrostatic potential V(r) generated by charge distribution in a cube file
"""
from DFTB.Analyse import Cube
from DFTB import AtomicData, XYZ
import numpy as np
import numpy.linalg as la

def electrostatic_potential_Poisson(atomlist, origin, axes, rho,
                                    conv_eps=1.0e-10, maxiter=100000,
                                    nuclear_potential=1,
                                    poisson_solver="pspfft"):
    """
    Compute the electrostatic potential generated by the density distribution rho(r)
    and the atomic point charges:
   
                /     rho(r')              Z(A)
       V(r) = - |dr' --------   +  sum_A ---------
                /     |r-r'|             |r - R_A|

    by solving the Poisson equation for the charge density rho(y)
       __2
       \/ V_elec(r) = - 4 pi rho(r)
    
    with the boundary condition V_elec(boundary) = 0.0

    Parameters
    ----------
    atomlist
    atomlist: list of tuples (Zi,posi) with nuclear geometry
    origin: 3d vector with origin of cube file
    axes: 3 vectors spanning a voxel
    rho: density values for each voxel,   rho[i,j,k] is the value of the voxel
       at position  x_ijk = origin + i*axes[0] + j*axes[1] + k*axes[2]

    Optional
    --------
    poisson_solver: choose solution method for Poisson equation, can be 'pspfft' or 'iterative'
    conv_eps: convergence threshold for iterative Poisson solver
    maxiter: maximum number of Jacobi iterations for iterative solver
    nuclear_potential: if > 0, add nuclear potential to total electrostatic potential

    Returns
    -------
    pot: electrostatic potential V(r) on the grid
    """
    if poisson_solver == "pspfft":
        try:
            from DFTB.Poisson.poisson_pspfft import poisson3d
        except ImportError as e:
            print e
            print "To be able to use the PSPFFT solver you have to "
            print "  - install the PSPFFT package from the Computer Physics Communications library"
            print "  - edit 'DFTB/Poisson/src/Makefile'"
            print "  - run 'make' inside the folder DFTB/Poisson/src"
            print ""
            exit(-1)
    else:
        from DFTB.Poisson.poisson_iterative import poisson3d
    
    nx,ny,nz = rho.shape
    # The axes have to be rectangular...
    assert abs(np.dot(axes[0], axes[1])) < 1.0e-10
    assert abs(np.dot(axes[1], axes[2])) < 1.0e-10
    #  and the points equidistant...
    dx = la.norm(axes[0])
    dy = la.norm(axes[1])
    dz = la.norm(axes[2])
    assert abs(dx - dy) < 1.0e-10
    assert abs(dx - dz) < 1.0e-10
    
    xvec = origin[0] + np.linspace(0.0, (nx-1)*dx, nx)
    yvec = origin[1] + np.linspace(0.0, (ny-1)*dy, ny)
    zvec = origin[2] + np.linspace(0.0, (nz-1)*dz, nz)
    dV = dx*dy*dz
    # screened nuclear charges
    Zeff = np.zeros(len(atomlist))
    for i,(Z,pos) in enumerate(atomlist):
        if Z >= 3:
            # core 1s^(2) electrons screen nuclear charge, so that the effective
            # charge is Z-2.
            Zcore = 2
        else:
            Zcore = 0
        Zeff[i] = Z-Zcore
        
    # total charge
    elec_charge = -np.sum(rho*dV)
    nuc_charge = np.sum([Z for (Z,pos) in atomlist])
    print "integrated electronic charge: %+7.5f  (core electrons probably missing)" % elec_charge
    print "sum of nuclear charges      : %+7.5f" % nuc_charge
    print "effective nuclear charge (screened by core electrons) : %+7.5f" % np.sum(Zeff)
    # electronic dipole
    x,y,z = np.meshgrid(xvec, yvec, zvec, indexing='ij')
    dip_elec_x = -np.sum(x*rho*dV) 
    dip_elec_y = -np.sum(y*rho*dV)
    dip_elec_z = -np.sum(z*rho*dV)
    print "elec. dipole (in e*bohr)    : %+7.5f  %+7.5f  %+7.5f" % (dip_elec_x, dip_elec_y, dip_elec_z)
    # nuclear dipole
    positions = XYZ.atomlist2vector(atomlist)
    nat = len(atomlist)
    dip_nuc_x = np.sum([Zeff[i]*positions[3*i+0] for i in range(0, nat)])
    dip_nuc_y = np.sum([Zeff[i]*positions[3*i+1] for i in range(0, nat)])
    dip_nuc_z = np.sum([Zeff[i]*positions[3*i+2] for i in range(0, nat)])
    print "nuc. dipole (in e*bohr)     : %+7.5f  %+7.5f  %+7.5f" % (dip_nuc_x, dip_nuc_y, dip_nuc_z)
    # total dipole
    dip_tot_x = dip_elec_x + dip_nuc_x
    dip_tot_y = dip_elec_y + dip_nuc_y
    dip_tot_z = dip_elec_z + dip_nuc_z
    print "elec+nuc dipole (in e*bohr) : %+7.5f  %+7.5f  %+7.5f" % (dip_tot_x, dip_tot_y, dip_tot_z)
    # convertsion factor   au -> Debye
    c = AtomicData.ebohr_to_debye
    print "elec+nuc dipole (in Debye)  : %+7.5f  %+7.5f  %+7.5f" % (c*dip_tot_x, c*dip_tot_y, c*dip_tot_z)


    # electrostatic potential of ELECTRONS
    source = -4*np.pi * rho
    # initial guess
    pot_elec_guess = 0.0*source

    print source.shape
    pot_elec = poisson3d(xvec,yvec,zvec, source, pot_elec_guess,
                         eps=conv_eps, maxiter=maxiter)

    if opts.nuclear_potential > 0:
        # electrostatic potential of NUCLEI
        print "potential from nuclei IS included"
        pot_nuc = 0*x
        for i,(Z,pos) in enumerate(atomlist):
            # Z/|r-R|
            pot_nuc += Zeff[i]/np.sqrt((x-pos[0])**2 + (y-pos[1])**2 + (z-pos[2])**2 + 1.0e-10)
            
        pot = -pot_elec  + pot_nuc
    else:
        print "potential from nuclei is IS NOT included"
        pot = -pot_elec    
        
    return pot

if __name__ == "__main__":
    import os.path
    import sys
    from optparse import OptionParser
    
    usage = "Usage: python %s <density.cube file> <potential.cube file>\n" % os.path.basename(sys.argv[0])
    usage += "  compute the electrostatic potential generated by the nuclei and charge distribution\n"
    usage += "  given in the input cube file (density.cube) and write the resulting potential to\n"
    usage += "  another cube file (potential.cube).\n"
    usage += "  see --help for all options.\n"
    usage += "\n"
    usage += "   Poisson Solvers\n"
    usage += "   ===============\n"
    usage += "  'iterative': The 3-dimensional Poisson equation is solved iteratively.\n"
    usage += "     The second order partial derivatives are replaced\n"
    usage += "     by finite differences and the resulting linear algebraic equations\n"
    usage += "     are solved using Jacobi iterations.\n"
    usage += "  'pspfft': faster solver based on Fourier transformation, requires the PSPFFT package\n\n"
    usage += "   Please note that the iterative Poisson solver may have difficulties\n"
    usage += "   producing solutions with the correct boundary condition V(r) -> 0 for r->inf.\n"

    usage += "\n"
    
    parser = OptionParser(usage)
    parser.add_option("--solver", dest="solver", type=str, help="Choose solution method for Poisson equation, can be 'pspfft' or 'iterative', [default: %default]", default="pspfft")
    parser.add_option("--conv_eps", dest="conv_eps", type=float, help="Convergence threshold for iterative Poisson solver [default: %default]", default=1.0e-10);
    parser.add_option("--maxiter", dest="maxiter", type=int, help="Maximum number of Jacobi iterations for iterative Poisson solver [default: %default]", default=1000000)
    parser.add_option("--nuclear_potential", dest="nuclear_potential", type=int, help="Should the nuclear potential be added to the electrostatic potential (0: no, 1: yes) [default: %default]", default=1)
    
    (opts, args) = parser.parse_args()
    if len(args) < 2:
        print usage
        exit(-1)
        
    rho_cube_file = args[0]
    pot_cube_file = args[1]

    # load cube file with electronic density
    print "load density from cube file..."
    atomlist, origin, axes, rho = Cube.readCube(rho_cube_file)
    print "compute electrostatic potential..."
    pot = electrostatic_potential_Poisson(atomlist, origin, axes, rho,
                                          poisson_solver=opts.solver,
                                          conv_eps=opts.conv_eps, maxiter=opts.maxiter,
                                          nuclear_potential=opts.nuclear_potential)
    # save potential
    Cube.writeCube(pot_cube_file, atomlist, origin, axes, pot)
    print "electrostatic potential saved to '%s'" % pot_cube_file

